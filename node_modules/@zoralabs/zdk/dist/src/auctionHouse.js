"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuctionHouse = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const typechain_1 = require("@zoralabs/auction-house/dist/typechain");
const _4_json_1 = tslib_1.__importDefault(require("@zoralabs/auction-house/dist/addresses/4.json"));
const _1_json_1 = tslib_1.__importDefault(require("@zoralabs/auction-house/dist/addresses/1.json"));
const _137_json_1 = tslib_1.__importDefault(require("@zoralabs/auction-house/dist/addresses/137.json"));
const _80001_json_1 = tslib_1.__importDefault(require("@zoralabs/auction-house/dist/addresses/80001.json"));
const addresses_1 = require("./addresses");
const utils_1 = require("./utils");
const auctionHouseAddresses = {
    rinkeby: _4_json_1.default.auctionHouse,
    mainnet: _1_json_1.default.auctionHouse,
    polygon: _137_json_1.default.auctionHouse,
    polygonMumbai: _80001_json_1.default.auctionHouse,
};
class AuctionHouse {
    constructor(signerOrProvider, chainId) {
        this.chainId = chainId;
        this.readOnly = !ethers_1.Signer.isSigner(signerOrProvider);
        this.signerOrProvider = signerOrProvider;
        const network = utils_1.chainIdToNetworkName(chainId);
        const address = auctionHouseAddresses[network];
        this.auctionHouse = typechain_1.AuctionHouse__factory.connect(address, signerOrProvider);
        this.zoraAddress = addresses_1.addresses[network].media;
    }
    async fetchAuction(auctionId) {
        return this.auctionHouse.auctions(auctionId);
    }
    async fetchAuctionFromTransactionReceipt(receipt) {
        for (const log of receipt.logs) {
            const description = this.auctionHouse.interface.parseLog(log);
            if (description.args.auctionId && log.address === this.auctionHouse.address) {
                return this.fetchAuction(description.args.auctionId);
            }
        }
        return null;
    }
    async createAuction(tokenId, duration, reservePrice, curator, curatorFeePercentages, auctionCurrency, tokenAddress = this.zoraAddress) {
        return this.auctionHouse.createAuction(tokenId, tokenAddress, duration, reservePrice, curator, curatorFeePercentages, auctionCurrency);
    }
    async setAuctionApproval(auctionId, approved) {
        return this.auctionHouse.setAuctionApproval(auctionId, approved);
    }
    async setAuctionReservePrice(auctionId, reservePrice) {
        return this.auctionHouse.setAuctionReservePrice(auctionId, reservePrice);
    }
    async createBid(auctionId, amount) {
        const { auctionCurrency } = await this.auctionHouse.auctions(auctionId);
        // If ETH auction, include the ETH in this transaction
        if (auctionCurrency === ethers_1.ethers.constants.AddressZero) {
            return this.auctionHouse.createBid(auctionId, amount, { value: amount });
        }
        else {
            return this.auctionHouse.createBid(auctionId, amount);
        }
    }
    async endAuction(auctionId) {
        return this.auctionHouse.endAuction(auctionId);
    }
    async cancelAuction(auctionId) {
        return this.auctionHouse.cancelAuction(auctionId);
    }
}
exports.AuctionHouse = AuctionHouse;
//# sourceMappingURL=auctionHouse.js.map